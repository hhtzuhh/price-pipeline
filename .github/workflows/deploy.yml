name: Deploy

on:
  push:
    branches:
      - main

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push Docker image
        run: |
          docker buildx build \
            --file Dockerfile \
            --tag ${{ secrets.DOCKER_USERNAME }}/market-data-service:latest \
            --push .

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0 # Action to set up SSH agent with your private key
        with:
          ssh-private-key: ${{ secrets.EC2_SSH_KEY }} # Use EC2 SSH private key from GitHub Secrets

      - name: Add EC2 to known hosts
        run: |
          mkdir -p ~/.ssh # Ensure .ssh directory exists
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts # Add EC2 host to known_hosts to avoid host key checking prompts
          chmod 600 ~/.ssh/known_hosts # Set correct permissions for known_hosts file

      -      - name: Deploy to EC2 with Docker Compose
        env:
          # Define environment variables that will be available within the 'run' block
          # These are for passing values INTO the EC2 shell via the `EOF` block
          REPO_NAME: ${{ github.repository }} # Pass the full repo name
          # Pass other secrets as environment variables that will be used inside the EOF block
          # IMPORTANT: These will be printed masked in GitHub Actions logs
          # Make sure these match the names you expect in your .env file
          POSTGRES_DB_ENV: ${{ secrets.POSTGRES_DB }}
          POSTGRES_USER_ENV: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD_ENV: ${{ secrets.POSTGRES_PASSWORD }}
          ALPHA_VANTAGE_API_KEY_ENV: ${{ secrets.ALPHA_VANTAGE_API_KEY }}
          KAFKA_BOOTSTRAP_SERVERS_ENV: ${{ secrets.KAFKA_BOOTSTRAP_SERVERS }}
          DATABASE_URL_ENV: ${{ secrets.DATABASE_URL }}

          # Docker Hub credentials, specifically for the 'docker login' inside the EOF block
          DOCKER_USERNAME_ENV: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASSWORD_ENV: ${{ secrets.DOCKER_PASSWORD }}

        run: |
          # Use HERE-document with a non-quoted EOF to allow variable expansion
          # However, to prevent unintended shell expansion on the runner for variables
          # intended for the EC2, we still need careful quoting or pass via ENV.

          # To safely pass secrets into the EOF block, we'll interpolate them directly,
          # as the 'run' command context provides them already.
          # The EOF marker MUST NOT BE QUOTED ('EOF') if you want interpolation here.
          # We'll use a unique marker like EOT (End Of Transmission) to avoid conflicts.

          ssh -i ~/.ssh/id_rsa ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << EOT
            # Set the shell on the remote host to bash for robust scripting
            # and ensure error propagation
            set -euo pipefail

            # Create the project directory if it doesn't exist
            mkdir -p ~/my-project
            cd ~/my-project

            # Clone or pull the latest code from your GitHub repository
            # Use the REPO_NAME environment variable passed from GitHub Actions
            if [ -d .git ]; then
              echo "Pulling latest code..."
              git pull
            else
              echo "Cloning repository..."
              git clone https://github.com/\${REPO_NAME}.git .
            fi

            # Create or update the .env file on the EC2 instance
            # Use the environment variables passed from GitHub Actions
            # Note: We are using \${VAR_NAME} inside EOT to defer shell expansion to EC2
            echo "POSTGRES_DB=\${POSTGRES_DB_ENV}" > .env
            echo "POSTGRES_USER=\${POSTGRES_USER_ENV}" >> .env
            echo "POSTGRES_PASSWORD=\${POSTGRES_PASSWORD_ENV}" >> .env
            echo "ALPHA_VANTAGE_API_KEY=\${ALPHA_VANTAGE_API_KEY_ENV}" >> .env
            echo "KAFKA_BOOTSTRAP_SERVERS=\${KAFKA_BOOTSTRAP_SERVERS_ENV}" >> .env
            echo "DATABASE_URL=\${DATABASE_URL_ENV}" >> .env

            echo ".env file updated."

            # Log in to Docker Hub on the EC2 instance
            # DOCKER_USERNAME_ENV and DOCKER_PASSWORD_ENV are directly passed from the workflow 'env'
            echo "\${DOCKER_PASSWORD_ENV}" | docker login --username "\${DOCKER_USERNAME_ENV}" --password-stdin
            echo "Logged into Docker Hub."

            # Pull the latest Docker images as defined in docker-compose.yml
            docker compose pull
            echo "Docker images pulled."

            # Bring up the Docker services in detached mode, removing any old orphaned containers
            docker compose up -d --remove-orphans
            echo "Docker services brought up."

            # Clean up Docker images not used by any container (optional, helps save disk space)
            docker image prune -f
            echo "Docker images pruned."

            # Log out from Docker Hub
            docker logout
            echo "Logged out from Docker Hub."
          EOT
